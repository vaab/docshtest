#+TITLE: docshtest

[[https://pypi.python.org/pypi/docshtest][https://img.shields.io/pypi/v/docshtest.svg]]
[[https://travis-ci.org/vaab/docshtest/][https://img.shields.io/travis/vaab/docshtest/master.svg?style=flat]]
[[https://ci.appveyor.com/project/vaab/docshtest/branch/master][https://img.shields.io/appveyor/ci/vaab/docshtest.svg]]
[[https://codecov.io/gh/vaab/docshtest/][http://img.shields.io/codecov/c/github/vaab/docshtest.svg?style=flat]]

Doctest for Shell - Quick, Slim and Dirty

* Feature

- Quick way to write doctest in shell
- Works on Windows, Linux, Python 2.7, Python 3.5+
- Slim because it has no dependencies to other project, one file, in python
- Doctest feeling
- You can mix python tests ans shell tests
- only checks standard output (although, you can tailor your test
  commands to output what is meaningful to standard output.)

* Current Status

This is an early alpha code.

Major concerns and shortcomings:

- end of blocks and final ~\n~ are not tested correctly
- tests execution in current directory with possible consequences.
- no support of checking error level
- no support of proper mixed standard error and standard output content
- limited to ~bash~ testing (needs ~bash -n~ equivalent)
- rough detection of ~doctests~ command blocks is relying on ~bash -n~
  error output. Not sure this is very solid.

Minor concerns, but would be better without:

- fail on first error hard-written.
- hard-written support of ~<BLANKLINE>~

Possible evolution:

- profiling
- support of python file (by extracting docs before)
- integration in nosetests ? is it possible ?
- colorize output ?
- coverage integration ?

* Installation

You don't need to download the GIT version of the code as ~docshtest~ is
available on the PyPI. So you should be able to run:

#+begin_example
pip install docshtest
#+end_example

If you have downloaded the GIT sources, then you could add install
the current version via traditional:

#+begin_example
python setup.py install
#+end_example

And if you don't have the GIT sources but would like to get the latest
master or branch from github, you could also:

#+begin_example
pip install git+https://github.com/vaab/docshtest
#+end_example

Or even select a specific revision (branch/tag/commit):

#+begin_example
pip install git+https://github.com/vaab/docshtest@master
#+end_example

* Usage

** QuickStart

~docshtest~ is a ~doctest~ for shell command. This means it allows
you to integrate in your documentation some examples of shell code and
their expected output that will be actually verifiable.

First please notice that these documentation lines you are reading are
stored in a ~README.org~ file that will contain very soon some
examples of how to run ~docshtest~ and what outcome to expect.

The very first example that comes to mind is to run ~docshtest~ on
this very documentation:

#+begin_example
docshtest README.org
#+end_example

You can check that yourself, and that's done in the CI procedures.

Let's introduce you the basics of writing your own testable
documentation...

So this is how it works - create an Org file with a ~docshtest~ source block:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ echo 'hello world'
hello world
,#+END_SRC
EOF
$ cat mydoc.org
,#+BEGIN_SRC docshtest
,$ echo 'hello world'
hello world
,#+END_SRC
#+END_SRC

Note that lines starting with ~,~ inside a docshtest block have the comma
stripped (standard Org escaping). This allows embedding ~#+BEGIN_SRC~ and
~$ ~ markers in heredocs and expected output.

The ~"$ "~ (dollar sign followed by a space) before the command to be
executed is required. Please refer to the following section to understand
how ~docshtest~ figures out the end of your shell code and the start of
the output.

The output starts after the end of your command, and will be matched
with the actual command output. If there is a mismatch the test will
fail, and ~docshtest~ will cancel any remaining tests. If it matches,
next test block will be executed.

To run our test:

#+BEGIN_SRC docshtest
$ ./docshtest mydoc.org
#0001 - success (line          2)
#+END_SRC

Org blocks can also be indented (under headings, in lists, etc.):

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
* My Section
,  #+BEGIN_SRC docshtest
,  $ echo 'indented block'
  indented block
,  #+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - success (line          3)
#+END_SRC

** RST Support

~docshtest~ also supports RST files using indented code blocks:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.rst

This is standard RST, we can include runnable test blocks::

    $ echo 'hello world'
    hello world

EOF
#+END_SRC

Note that indentation (4 spaces) is required for RST format.

To run our test:

#+BEGIN_SRC docshtest
$ ./docshtest mydoc.rst
#0001 - success (line          4)
#+END_SRC

RST multiline commands also work:

#+BEGIN_SRC docshtest
$ cat <<EOF > mydoc.rst

Multiline commands::

    $ for a in \$(seq 1 3); do
        echo "foo\$a"
      done
    foo1
    foo2
    foo3

EOF
$ ./docshtest mydoc.rst
#0001 - success (lines       4-6)
#+END_SRC

** Multiline Commands

Multiline commands are detected with a very simple, but dirty method,
~docshtest~ will simply provide the exact code, starting with only
the first line to the shell interpreter, if the shell interpreter
complains, it'll try again by adding the next line to the output.

This allows to document/test multi-line shell codes like:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ for i in 1 2 3; do
    echo "num $i"
  done
num 1
num 2
num 3
,#+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - success (lines       2-4)
#+END_SRC

Please note that the extra indentation for the body of the ~for~ loop or
the ~done~ is unnecessary, but is recommended for reading:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ for i in 1 2 3; do
  echo "num $i"
done
num 1
num 2
num 3
,#+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - success (lines       2-4)
#+END_SRC

Failing test will display both expected output and current output:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ for i in 1 2 3; do
    echo "num $i"
  done
num 1
num 4
num 3
,#+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - failure (lines       2-4):
  command:
  | for i in 1 2 3; do
  |     echo "num $i"
  |   done
  expected:
  | num 1
  | num 4
  | num 3
  |
  output:
  | num 1
  | num 2
  | num 3
  |
#+END_SRC

But note that if these outputs are bigger, a standard unified diff will be
printed:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ for i in 1 2 3 4 5 6; do
    echo "num $i"
  done
num 1
num 3
num 4
num 5
num 6
,#+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - failure (lines       2-4):
  command:
  | for i in 1 2 3 4 5 6; do
  |     echo "num $i"
  |   done
  expected:
  | num 1
  | num 3
  | num 4
  | num 5
  | num 6
  |
  output:
  | num 1
  | num 2
  | num 3
  | num 4
  | num 5
  | num 6
  |
  diff:
  --- expected
  +++ output
  @@ -1,4 +1,5 @@
   num 1
  +num 2
   num 3
   num 4
   num 5
#+END_SRC

** Multiple Blocks

Multiple test blocks in one file:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
First block:

,#+BEGIN_SRC docshtest
,$ echo 'first'
first
,#+END_SRC

Second block:

,#+BEGIN_SRC docshtest
,$ echo 'second'
second
,#+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - success (line          4)
#0002 - success (line         11)
#+END_SRC

** Tinkering all executed code

You can transform all executed code before execution thanks to
~--regex REGEX~ (or ~-r REGEX~) option:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ foo 'hello world'
hello world
,#+END_SRC
EOF
$ ./docshtest -r '#\bfoo\b#echo#' mydoc.org
#0001 - success (line          2)
#+END_SRC

** Conditional Tests

You might want to have conditional tests, that are triggered only
on if specific test succeeds. This feature uses ~meta~ commands
that are specified as shell comments in the given block:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ echo $ENVVAR       ## docshtest: if-success-set VAR_WAS_SET
0
,$ echo 'var is set'  ## docshtest: ignore-if VAR_WAS_SET
SHOULDFAIL
,$ echo 'var is not set'  ## docshtest: ignore-if-not VAR_WAS_SET
SHOULDFAIL
,#+END_SRC
EOF
$ ENVVAR=0 ./docshtest mydoc.org
#0001 - ignored (line          2): if-success-set VAR_WAS_SET
#0002 - ignored (line          4): ignore-if VAR_WAS_SET
#0003 - failure (line          6):
  command:
  | echo 'var is not set'  ## docshtest: ignore-if-not VAR_WAS_SET
  expected:
  | SHOULDFAIL
  |
  output:
  | var is not set
  |
#+END_SRC

** Case Insensitivity

Org-mode keywords are case-insensitive:

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+begin_src docshtest
,$ echo 'lowercase'
lowercase
,#+end_src
EOF
$ ./docshtest mydoc.org
#0001 - success (line          2)
#+END_SRC

** Encoding

~docshtest~ will assume everything is "UTF-8":

#+BEGIN_SRC docshtest
$ cat <<'EOF' > mydoc.org
,#+BEGIN_SRC docshtest
,$ echo "éà"
éà
,$ echo "é"
e
,#+END_SRC
EOF
$ ./docshtest mydoc.org
#0001 - success (line          2)
#0002 - failure (line          4):
  command:
  | echo "é"
  expected:
  | e
  |
  output:
  | é
  |
#+END_SRC

** Escaping Expected Output

If the expected output of a command starts with ~$ ~ (which would
normally be interpreted as a new command), you can escape it with a
backslash:

#+BEGIN_SRC docshtest
$ echo '$ hello'
\$ hello
#+END_SRC

To get a literal backslash at the start of expected output, escape it
with another backslash:

#+BEGIN_SRC docshtest
$ echo '\$ hello'
\\$ hello
#+END_SRC

Multiple escapes can be chained:

#+BEGIN_SRC docshtest
$ echo '\\ starts with backslash'
\\\\ starts with backslash
#+END_SRC

Note that escaping only applies at the very start of a line and only
for ~$~ and ~\~ characters. Backslashes elsewhere in the line are
not affected.

** Command line

~docshtest~ supports the common GNU standard ~--help~ options:

#+BEGIN_SRC docshtest
$ ./docshtest --help

docshtest - parse file and run shell doctests

Usage:

    docshtest (-h|--help)
    docshtest [[-r|--regex REGEX] ...] DOCSHTEST_FILE


Options:

    -r REGEX, --regex REGEX
              Will apply this regex to the lines to be executed. You
              can have more than one patterns by re-using this options
              as many times as wanted. Regexps will be applied one by one
              in the same order than they are provided on the command line.


Examples:

     ## run tests but replace executable on-the-fly for coverage support
     docshtest README.rst -r '/\bdocshtest\b/coverage run docshtest.py/'
<BLANKLINE>
<BLANKLINE>
#+END_SRC

First argument is necessary:

#+BEGIN_SRC docshtest
$ ./docshtest
Error: please provide a rst filename as argument. (use '--help' option to get usage info)
#+END_SRC

And of course it should be the path of a file:

#+BEGIN_SRC docshtest
$ ./docshtest notexistent
Error: file 'notexistent' not found.
#+END_SRC

* Contributing

Any suggestions or issues are welcome. Push requests are very welcome,
please check out the guidelines.

** Push Request Guidelines

You can send any code. I'll look at it and will integrate it myself in
the code base and leave you as the author. This process can take time and
it'll take less time if you follow the following guidelines:

- Try to stick to 80 columns wide.
- separate your commits per smallest concern.
- each commit should pass the tests (to allow easy bisect)
- each functionality/bugfix commit should contain the code, tests,
  and doc.
- prior minor commit with typographic or code cosmetic changes are
  very welcome. These should be tagged in their commit summary with
  ~!minor~.
- the commit message should follow gitchangelog rules (check the git
  log to get examples)
- if the commit fixes an issue or finished the implementation of a
  feature, please mention it in the summary.

If you have some questions about guidelines which is not answered here,
please check the current ~git log~, you might find previous commit that
shows you how to deal with your issue.

* License

Copyright (c) 2012-2026 Valentin Lab.

Licensed under the [[http://raw.github.com/0k/sunit/master/LICENSE][BSD License]].
